#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

// 指针初级
int m10()
{
	/*
		在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向
	（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以
	说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址
	的内存单元
	*/

	// 指针的定义，用 数据类型* 表示 int * 表示整形指针
	// 不同类型的指针决定了 指针+ - 整数时向前或向后移动的字节数
	// 不同类型的指针在解引用是占用的字节数不同
	int* p = NULL;
	float* fp = NULL;
	double* dp = NULL;
	char* cp = NULL;

	// 指针的大小，在32位平台是4个字节，64位平台是8个字节
	// 指针的类型包括基本的数据类型的指针
	// 不同指针 加一减一 对指针本身的影响
	// int型指针 每次加一指针就会后移四个字节
	int arr[10] = { 0 };
	p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*p = i;
		p += 1;
	}

	// 指针的解引用 *指针名称
	float a = 1.11f;
	fp = &a;
	printf("%lf\n", *fp); // 这里就是对fp指针解引用后打印

	// 野指针
	// 没有初始化，指针调用越界，指针指向地址被释放
	//*dp = 12.111; // 这里就是野指针，指针没有初始化，虽然指针定义时是null但是没有指向具体的内存地址，所以这里的调用是不合法的
	//p += 10;
	//*p = 10; // 这里也是野指针，虽然指针有初始化，但是当指针指向第十个元素的时候已经超越数组下标，产生越界
	//int* mp = ip(); // 这里也是野指针，指针ip会随着ip函数的执行结束而被释放，变量i在内存中已经没有具体地址，这是返回给mp的地址是无效的地址

	// 避免产生野指针的方法
	//1. 指针初始化
	//2. 小心指针越界
	//3. 指针指向空间释放即使置NULL
	//4. 指针使用之前检查有效性


	// 指针 - 指针
	int arrs[4] = { 1, 2, 3, 4 };
	int* start = arrs;
	int* end = arrs + 4;
	int len = end - start;
	printf("end - start = %d\n", len); // 指针相减可以计算出两个指针中间的元素个数

	// 指针和数组的关系
	// 在C语言中，数组名就是数组的首元素地址（首元素首字节地址）
	int addres[5] = { 0 };
	printf("addres = %p  <=> addres[0] = %p\n", addres, &addres[0]); // addres = 0098FA8C  <=> addres[0] = 0098FA8C

	int* ap = addres; // 吧数组的首元素地址保存到ap指针内
	int c = 0;
	for (c = 0; c < 5; c++)
	{
		*(ap + c) = c; // 通过改变指针的指向，给数组元素赋值
	}
	for (c = 0; c < 5; c++)
	{
		// 因为数组名是首元素地址, [] 是下表引用操作符
		// arr[2] => *(ap + 2) => *(2 + ap) => *(2 + arr) => 2[arr]
		printf("%d ", addres[c]);

	}
	printf("\n");

	printf("----------------------------\n");
	int ads[3] = { 1, 2, 3 };
	printf("ads[2] = %d\n", 2[ads]);

	// 二级指针
	int levelOne = 1; // 这是一个整形变量
	int* lp = &levelOne; // 这是一个指针
	int** llp = &lp; // 这是一个二级指针
	// 由于指针是内存中指向变量的地址，所以lp内保存的就是levelOne变量的内存地址，而lp本身也是变量(指针变量)也需要在内存中开辟地址,llp就保存的是lp的内存地址,也就是二级指针
	// 二级指针的节引用
	// *llp  （对llp进行一次解引用）得到的是lp 的内存地址
	// **llp （对llp进行两次解引用）得到的是 levelOne 的值


	// 指针数组
	// int arr[6] 整形数组
	// int * arr[6] 指针数组
	//int* pointer[6] = NULL; // 这就是一个指针数组，使用和整形数组相同
	return 0;
}

int* ip()
{
	int i = 10;
	int* ip = &i;
	return ip;
}

